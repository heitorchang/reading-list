See: skipped.txt

8 a page controller is a class that derives from PageModel

15 a provider is a component that handles communication between C# code and the data store

21 New webapp

dotnet new webapp -o WebApplication1

// looks like sln (solution) file is not necessary

24 New page

dotnet new page -n Welcome -o Pages --namespace WebApplication1.Pages

NOTE: -na does not work

-n name
-o output location
--namespace for the generated C# files

24 hot reload

in the directory containing WebApplication1.csproj, run

dotnet watch run

25
@{
  ViewData["Title"] = "Welcome";
}

28 a Solution file acts as a container for managing related projects (such as a business logic layer and a data access layer)

the .csproj file contains information about the project for the build system.

bin, obj: used in the build process

WEB gitignore:

https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

Properties: contains launchSettings.json, settings which are used when you run the application

wwwroot: is configured to be run directly. should contain stylesheets, JS files, images, and other static files (not needed to be processed)

Pages: the home of your Razor page files.

31 the top-level (.cshtml) file is called the "content" or "view" file. In this book, it is called the "Razor page"

the .cshtml.cs file is a C# file containing a class that derives from PageModel.

appsettings.json has a development and a production version.

32 WebApplicationBuilder properties:

Environment: information about the web-hosting environment the app runs in

Services: Service container (covered in Ch. 7)

Configuration: enables composition of the configuration providers (covered in Ch. 14)

Logging: configuration via ILoggingBuilder

Host: configure application-host-specific services, such as third-party DI (Dependency Injection) containers

WebHost: web server configuration

33 bootstrapping: the initial configuration of the application

33 the default web server is Kestrel

34 builder.Services.AddRazorPages() includes the view engine, model binding, request validation, tag helpers, memory cache, and ViewData.

34 the configured application is an instance of the WebApplication type. It merges:

IApplicationBuilder (configures request or middleware pipeline)
IEndpointRouteBuilder (configures mapping incoming requests to specific pages)
IHost (provides the means to start and stop the application)

34 an IWebHostEnvironment is accessible via the app.Environment property.

35 HTTP (HyperText Transfer Protocol) is used to transfer information between systems in the client-server model. A request is the input, and the response is the output.

37 request methods: GET, POST, PUT, DELETE

37 headers are name-value pairs that provide additional information to the server.

38 the information of an HTTP transaction is encapsulated in the HttpContext class.

Properties of HttpContext:
Request
  Body
  ContentLength
  ContentType
  Cookies
  Form
  Headers
  IsHttps
  Method
  Path
  Query
Response
  ContentLength
  ContentType
  Cookies
  HasStarted
  Headers
  StatusCode
  WriteAsync
  Redirect
Connection
Session
User (see ch. 9 and 10)

39 the decision-making process (where to direct the request, logging, compression, what to return) is the "request pipeline". The individual components that perform these functions are known as middleware.

40 a middleware component can short-circuit the data flow (for example, the static files middleware can return a file if it's determined to be static).

skipped custom middleware p. 41-48

50 layouts are a kind of master template for multiple pages.
partial files are snippets of UI that can be plugged into a host page or layout.

51 PageModel is a feature of Razor Pages that acts as both an MVC controller and a view model (a container for data specific to a particular view or page)

tag helpers are components that enable server-side code to generate HTML

an IActionResult is a return type of a handler method

51 "Template View" is a common design pattern in web development frameworks. it uses markers or placeholders for server-side content.

51 Razor syntax uses @ as a transition marker

52 @page and @model WebApplication1... are directives
@{ ... } is a C# code block
<p>It is @day ... is an inline C# expression

the using directive brings namespaces into scope (allows its types to be referenced without their fully qualified names)

example:
@using static System.IO.Path
@ {
  var extension = GetExtension("myfile.ext");
}

53 _ViewImports.cshtml centralizes directives for all cshtml files.

53 WARNING: putting too much application logic in Razor pages and mixing it with HTML (in .cshtml files) makes it very difficult to test

an algorithm may be placed in its own class

54 a functions block looks like:

@functions{
  ...
}

functions blocks should be avoided in Razor pages for the same reason business logic should be avoided (mixing logic with HTML complicates testing)

a reasonable use of a functions block is to write small routines that manage presentation logic and only apply to the page in which they are placed.

55 expressions such as @partOfDay are "implicit expressions". an explicit expression uses parentheses:

@(DateTime.Now.Hour > 12 ? "PM" : "AM")

55 Control blocks in Razor

@if(DateTime.Now.Hour <= 12)
{
  <p>It is morning.</p>
}
else if (...)
{
  <p>Afternoon</p>
}
else
{
  <p>Evening</p>
}

56

@switch (DateTime.Now.Hour)
{
  case int _ when DateTime.Now.Hour <= 12:
    <p>Morning</p>
    break;
  case int _ when ...
    ...
    break;
  default:
    <p>Evening</p>
    break;
}

56 foreach: listing vacation destinations

@functions{
  public class City
  {
    public string Name { get; set; }
    public string Country { get; set; }
  }
  List<City> cities = new List<City>{
    new City { Name = "Paris", Country = "France" },
    new City { Name = "Rome", Country = "Italy" },
    new City { Name = "Madrid", Country = "Spain" }
  };
}

<ul>
  @foreach (var city in cities)
  {
    <li>@city.Name is in @city.Country</li>
  }
</ul>

57 @:something and <text>something</text> is used to render HTML inside a code block.

58 by default, Razor encodes unsafe characters such as <, >, and & to HTML equivalents (&lt;, &gt;, etc.)

@{
  var output = "<p>a paragraph</p>";
}
@output will show up as <p>a paragraph</p> in the browser.

58 use
@Html.Raw("<p>a paragraph</p>") but you must be sure the contents are sanitized.

59 to prevent encoding non-ASCII characters, add to WebEncoderOptions in Program.cs:

builder.Services.Configure<WebEncoderOptions>(options =>
{
  options.TextEncoderSettings = new
  TextEncoderSettings(UnicodeRanges.BasicLatin, UnicodeRanges.Latin1Supplement);
});

or instead of individual ranges, use
UnicodeRanges.All

skipped templated Razor delegates p. 59-61

62 Razor comments
@* ... *@

63 layout files contain a method called RenderBody, @RenderBody()

64 specifying the layout page

@{
  Layout = "_Layout";

  // OR

  Layout = "/Pages/Shared/_Layout.cshtml";
}

65 Setting the layout in every page suffers from the same problem as not having a layout page: updating it in multiple locations becomes a chore.

the file _ViewStart.cshtml (found in /Pages/) executes its code before any page that it affects (all Razor pages in the same folder and subfolders).

order of execution: ViewStart -> Content -> Layout

settings may be overridden by pages further down this order

layouts may be nested

WARNING: the ViewStart file cannot be relied on to set the parent layout file in a child layout. The ViewStart file has no effect over layouts within its folder and subfolders.

66 the @section directive will include a section (that contains optional content) that depends on a particular destination.

@section ThingsToDoWidget{
  <p>Visit Eiffel Tower</p>
}

You render the content of a section within the layout page by calling "RenderSectionAsync" at the location where you want the content to appear.

There are three versions:
taking the section's name as a string
taking a Boolean (true or false) that indicates whether all content pages are required to define the section
taking both a string and a Boolean

@await RenderSectionAsync("ThingsToDoWidget", required: false)

67 determine if a content page has defined a specific section
<div class="card">
@if (IsSectionDefined("ThingsToDoWidget"))
{
  @await RenderSectionAsync("ThingsToDoWidget")
}
else
{
  <p>Things to do default content</p>
}
</div>

IgnoreSection("admin");

IgnoreSection returns void so it doesn't start with @ and must be terminated with a semicolon.

68 a partial view (.cshtml) contains a chunk of HTML and some optional Razor syntax. it doesn't have a @page directive.

They are used to:
* break up a complex UI into more manageable pieces
* avoid repetition
* generate HTML for async page updates in AJAX scenarios

with VS Code, add a new file with the .cshtml suffix or generate a new ViewStart or ViewImports file and remove the default content:

dotnet new viewstart
dotnet new viewimports

conventionally (but not mandatory) partials' filenames should start with a leading underscore, such as _myPartial.cshtml.

partials are looked for in the same folder containing the current page, Pages/Shared, and Views/Shared.

_NavigationPartial should be placed in the Pages/Shared folder.

69 a partial tag helper will render the contents of a partial view in the calling page:

<partial name="_NavigationPartial" />

70 a @model directive at the top of the partial file allows for displaying dynamic content.

@model Dictionary<string, string>

data for the partial is represented by a property of the host page named "Nav", and is passed to the partial tag helper's "model" attribute:

<partial name="_NavigationPartial" model="Model.Nav" />

70 Tag helpers are components that automate the generation of HTML. most attributes are custom and begin with "asp-"

71 tag helpers are optional, but are enabled by default in the _ViewImports.cshtml file in /Pages/

@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers

Note: this book doesn't cover creation of custom tag helpers.

71 tag helpers may be removed.

the ! prefix to a tag name opts out of individual tags (add to both start and end tags)

<!a href="http://www.microsoft.com">Microsoft</!a>

72 to opt specific tags into processing, register a custom prefix

@tagHelperPrefix x:
<x:a asp-page="/Index">Home</x:a>

this minimizes visual confusion; for example, for designers

72 view components are similar to partial views, but should be preferred over partials when there is server-side logic or its own source of data (e.g. database-driven menus, shopping carts, or tag clouds). Note: covered in Ch. 14)

73 the two primary roles of a PageModel class are the controller and view model.

The role of a controller is to take requests, use that information to perform commands on the model, and then return the result of that processing.

as part of the request processing, the controller has to prepare the data passed to the view in a form the view can work with. this form is the "view model".

73 ViewData is also a way to pass data to view pages.

The PageModel class is generated automatically when a Razor page is added to the application. It is named after the page, plus Model, e.g. WelcomeModel.

Public PageModel properties are exposed to the Razor page through the inclusion of a @model directive that references the PageModel type.

73 The recommended approach to pass data to pages is using a strongly typed view model.

ViewData is a weakly typed option shown before to pass the page Title (p. 25)

ViewData is a dictionary-based feature (key-value pairs).

Definition:
@{
  ViewData["Title"] = "Welcome";
}

Access:
<title>@ViewData["Title"]</title>

The values are "object" types (anything goes)

74 example of datetime rendering:
@(((DateTime)ViewData["SaleEnds"]).ToString("h tt, MMMM dd, yyyy"))

74 for assignment to take effect in the Razor page, it must include a @model directive referencing the appropriate Model type:

@model WelcomeModel

Model assignments may be overridden by the Razor page

75 ViewBag is a property that wraps ViewData that enables you to treat it as a dynamic object.

NOTE: using it is not recommended

@ViewBag.SaleEnds

it is available only in Razor files.

75 ViewData should be used sparingly because it relies on magic strings (key names) and is weakly typed (public PageModel properties should be used)

75 a view model is simple: a class that encapsulates the data required for a particular view or page. It is like a static database view. it contains a subset of data

76 Example: OrderSummaryView that shows ProductId, Name, Price, CustomerId, and CustomerAddress

76 An example view model class

public class OrderSummaryViewModel
{
  public int Customer { get; set; }
  public string CustomerName { get; set; }
  public string CustomerAddress { get; set; }
  public int ProductId
  public string ProductName { get; set; }
  public decimal ProductPrice { get; set; }
}

views for view models include a @model directive:

@model OrderSummaryViewModel

a PageModel is a view model in the MVC sense.

77 a PageModel may contain public properties that are dynamic data:

public class WelcomeModel : PageModel
{
  public DateTime SaleEnds { get; set; } = new DateTime(DateTime.Now.Year, 6, 30);
  public void OnGet()
  {
  }
}

Razor page:

@page
@model WebApplication1.Pages.WelcomeModel
@{
}
<p>Sale ends at @Model.SaleEnds.ToString("h tt, MMMM dd, yyyy")</p>

IntelliSense kicks into life with this approach, as opposed to using ViewData

78 Request processing in a PageModel is performed via handler methods (analogous to controller actions)

On[method name] with Async (optionally)
that is: OnGet, OnGetAsync, OnPost, OnPostAsync

79 in C#, a dollar sign before a string means ith should be interpolated

public class WelcomeModel : PageModel
{
  public string Message { get; set; }

  public void OnGet(int id)
  {
    Message = $"OnGet executed with id = {id}";
  }
}

79 the asp-route-* attribute is used in an <a> tag to pass data in the URL

<a asp-page="/Welcome" asp-route-id="5">Get welcome</a>

80 There can only be one kind of OnGet (cannot have both OnGet and OnGetAsync)

81 It is possible to have named handler methods, such as OnPostSearch and OnPostRegister

81 the asp-page-handler attribute must be used to determine which handler to use

<form method="post" asp-page-handler="Search">...</form>
<form method="post" asp-page-handler="Register">...</form>

82 Handler methods return void, the type "Task", or action results of the interface type "IActionResult".

Action results may be returning a file, an empty response, a specific HTTP status code, or a redirection.

return types of void or Task implicitly return a PageResult, an action that renders a RazorPage. in general, it is not necessary to explicitly return a PageResult.

83 Common ActionResults and associated helper methods:

PageResult: Page (a Razor page)
FileContentResult: File
NotFoundResult: NotFound
PartialResult: Partial
RedirectToPageResult: RedirectToPage, RedirectToPagePermanent (Note: avoid permanent redirects)
StatusCodeResult: StatusCode

84 If multiple result types need to be returned, IActionResult should be specified as the return type for the handler method:

public IActionResult OnGet(int id)
{
  var data = db.Find(id);
  if (data == null)
  {
    return NotFound();
  }
  else
  {
    return Page();
  }
}


126 WARNING: using [BindProperties] in model binding will result in all public properties being available to the client, and vulnerable to an "overposting" (also called "mass assignment") attack.

WEB scaffolding tool
https://learn.microsoft.com/en-us/aspnet/core/tutorials/razor-pages/model?view=aspnetcore-7.0&tabs=visual-studio-code

dotnet tool uninstall --global dotnet-aspnet-codegenerator
dotnet tool install --global dotnet-aspnet-codegenerator
dotnet tool uninstall --global dotnet-ef
dotnet tool install --global dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Microsoft.EntityFrameworkCore.SQLite
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
