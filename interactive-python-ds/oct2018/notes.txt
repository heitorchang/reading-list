https://runestone.academy/runestone/static/pythonds/index.html

Problem Solving with Algorithms and Data Structures using Python

1.1 Problem solving, abstraction, abstract data types

1.2 Review the framework within which computer science and the study of algorithms and data structures must fit

1.3 Computers are just tools

An algorithm is a step-by-step list of instructions for solving any instance of a problem that might arise. They are finite and give solutions.

A problem is computable if there is an algorithm to solve it. Computer Science studies both solvable and unsolvable problems

Abstraction separates logical and physical perspectives. For example, the functions of a car from a logical perspective is braking, steering and accelerating. Such functions are called the interface. The user is called the client.

The car's physical perspective is of interest to a mechanic. He must know how the engine works (details "under the hood").

Procedural abstraction is separating the interface from its implementation. We can call math.sqrt without knowing how it works.

1.4 Programming is the process of taking an algorithm and encoding it into a language's notation that is understood by a computer.

Control constructs such as sequential processing, decision making and iteration allow representation of algorithmic steps unambiguously

Data types provide an interpretation of raw binary data. They are also called "Primitive data types" (for example, integers)

1.5 Abstractions help manage the complexity of problems.

An Abstract Data Type (ADT) is a logical description of how we view the data and apply operations without regard to how it will be implemented.

This level of abstraction creates an encapsulation around the data (also called information hiding)

The implementation (physical view) of an ADT is a data structure

The separation of logical and physical views allow an implementation-independent view of the data

1.6 By seeing how algorithms are designed, we can develop pattern recognition.

There will often be trade-offs we need to identify and decide upon.

1.7 Python is an interpreted, object-oriented programming language. It considers data to be the focal point of the problem-solving process

1.8 A class is a description of what the data looks like (the state) and what they can do (the behavior). A class is analogous to an Abstract Data Type.

Data items are called objects (instances of a class)

1.8.1 Built-in Atomic Data Types

numeric: int, float
arithmetic: +, -, *, /, **, %, //
boolean: True, False, and, not
<, >, <=, >=, ==, !=

Assignment (theSum = 0) associates a name with a value. The variable will hold a reference to a piece of data and not the data itself.

(StackOverflow) ints are immutable, so when changing the value of a local variable (inside a function), a new integer object is created.

Re-assignment inside a function moves the reference to a new object, while changes to a mutable object (alist[0] = 0) does not change the alist reference itself.

Python is dynamic: the same variable can refer to many different types of data

1.8.2 Built-in Collection data Types

Ordered: List, String, Tuple
Unordered: Dictionary, Set

Lists are heterogeneous (elements need not be of the same class)

List Operations
indexing      [i]
concatenation +
repetition    *
membership    in
length        len()
slicing       [a:b:step]

Indices start counting with 0. Slice index a is included, but b is not.

When repeating a list, the references are copied. So a repeated nested list is the same list. Changing it in one place will affect all other copies.

List methods

alist.append(item)
.insert(i, item) inserts item into the ith position
.pop(), .pop(i)
.sort(), .reverse()
.index(item)
.count(item)
.remove(item) removes the first occurrence of item
del alist[i]

list(range(5, 10, 2)) => [5, 7, 9]

String methods
(sequence operations also work)
Alignment: center, ljust, rjust
Case: upper, lower, swapcase, title
count, find, rfind, index, rindex

find vs. index
s.index('a') will raise ValueError if it doesn't find the argument
find returns -1
Mnemonic: -1 is not found, you can't say not index. Also, -1 is the last character.

split uses the argument as division points or whitespace if there are no arguments.

Lists are mutable, strings and tuples are not.

Sets do not allow duplicates.
The empty set is set()
a | b Union (all elements from both sets)
a & b Intersection (elements common to both)
a - b Difference (elements in a but not in b)
a <= b Asks whether all elements of a are in b (isSubset)

add, remove, pop, clear
pop removes an arbitrary element from the set

Dictionaries are collections of associated pairs of keys and values

capitals = {'Iowa': 'Des Moines', 'Wisconsin', 'Madison'}
capitals['California'] = 'Sacramento'

list(adict) returns the keys

keys, values, and items return objects. They may be converted to lists.

adict.get('akey', 'not found') returns the value associated to 'akey' or 'not found' if that key is not present. Without the second argument, .get() returns None if the key is not found.

1.9

aName = input('Please enter your name: ')
input() returns a string
in Python 2, use raw_input()

use float() or int() to convert to numbers

print(a, b, c, sep="***", end="!!\n")

formatted string
print("%s is %d years old." % (aName, age))

there is a .format() method not covered in this book

1.10 Control Structures
counter = 1
while counter <= 5:
    print(counter, end=" ")
	counter += 1

=> 1 2 3 4 5

and, or are short-circuit operators

for item in [1, 3, 6, 5, 0]:

for i in range(5):

for aletter in aword:

if ... else
if ... elif ... elif ... else

[Internet] 'else' at the end of for and while loops are executed if the loop completes (is not interrupted by break, for example)

list comprehension: add 10 to odd integers
[x + 10 for x in range(10) if x % 2 == 1]
=> [11, 13, 15, 17, 19]

a = [1, 1, 0]
['T' if n == 1 else 'F' for n in a]
=> ['T', 'T', 'F']

1.11 Exception Handling

A syntax error occurs when there's a mistake in the structure of a statement or expression

[PyRef] A simple statement is comprised within a single logical line

Expression statements are mostly used interactively, to compute and write a value or to call a procedure

a logic error occurs when the program executes but gives the wrong result. If a situation such as division by zero or list access out of bounds occurs at runtime, it is called an exception

Exceptions are raised and handled

try ... except blocks are used to handle potential exceptions. The except block "catches" the exception.

The programmer can raise his or her own exceptions

raise RuntimeError("can't use negative numbers")

1.12 Defining Functions

A function hides the details of a computation

A function definition requires a name, a group of parameters, and a body. It may explicitly return a value

(an argument is a value given to a function; try 's'.join(). It raises TypeError: join takes exactly one argument (0 given))

Newton's method for square roots:
newguess = (1/2) * (oldguess + (n / oldguess))

1.13 Defining classes

A programmer may create new classes to model data that is needed to solve the problem.

To implement an abstract data type, we use a new class.

1.13.1 Fraction

3 (numerator)
- 
5 (denominator)

class Fraction:
    def __init__(self, top, bottom):
	    self.num = top
		self.den = bottom

self is a special parameter that is used as a reference back to the object itself.

'self' must always be the first formal parameter

To create an instance, we invoke the constructor:
myFraction = Fraction(3, 5)

we want to override the __str__ method to get an useful result with print().

[Fluent Py] __repr__ should be "as-code"
    return "Fraction({}, {})".format(self.num, self.den)

override __add__ method

Euclid's algorithm for GCD
[sicp]

def gcd(a, b):
    if b == 0:
	    return a
	return gcd(b, a % b)

In this Fraction implementation, a negative fraction will have a negative numerator.

shallow equality is when two references (variables) refer to the same object

deep equality is when two distinct objects have the same value (not the same reference). __eq__ and __le__ may be overridden.

1.13.2 Inheritance: Logic gates and circuits

Inheritance is the ability for one class to be related to another. Child classes can inherit characteristic data and behavior from a parent class

Child classes are called subclasses and parents are called superclasses. A child and parent follow a "is-a relationship".

The most general class for the digital circuit simulation is LogicGate

The general LogicGate class uses performGateLogic, which will be implemented by subclasses.

class UnaryGate(LogicGate):
	def __init__(self, n):
    	super().__init__(n)
		# Or super(UnaryGate, self).__init__(n)
		LogicGate.__init__(self, n)

Child class constructors need to call parent class constructors and then move on to their distinguishing data.

The connector class is not part of the gate hierarchy, but follows a "has-a" relationship. A connector has two gates. "Has-a" does not involve inheritance.

2.1 Analysis

Big-O execution time of common list and dictionary operations

2.2 How do we decide one program is better than another?

There may be many programs for the same algorithm

Algorithm analysis is concerned with comparing the amount of computing resources (time and memory) each algorithm uses

Benchmarking actual time to run an algorithm is not really useful because it is dependent on a particular machine, program, and language

def sumOfN(n):
    start = time.time()
	theSum = ...
	end = time.time()
	return theSum, end - start

2.3 Big-O notation

To characterize efficiency independent of a particular program or computer, it is important to quantify the number of operations.

For a function T(n) denoting the number of operations (such as assignment), the most dominant part is the "order of magnitude" function, O(f(n)). f(n) is a simple representation of the dominant part of T(n).

For algorithms that depend on the exact values of the data, we may characterize their performance in terms of best case, worst case, or average case

common orders of magnitude are:

f(n)     name
1        constant
log n    logarithmic
n        linear
n log n  log linear
n^2      quadratic
n^3      cubic
2^n      exponential
n!       factorial

2.4 Check if two strings are anagrams

2.4.1 "check off" characters from the first string by replacing characters in a list (converted from the second string) with None as they are seen. It is O(n^2)

2.4.2 Sort and compare
Sort both strings alphabetically and compare them. Its time complexity depends on the sorting algorithm used, typically O(n log n)

2.4.3 Brute force (exhaust all possibilities)
There are n characters for the first position, n-1 for the second, and so on. It is O(n!)

2.4.4 Count and compare
Use a list of 26 counters, each for a possible letter. Then compare the two lists. This algorithm is O(n) but requires additional storage. It sacrifices space in order to gain time

2.5 Performance of Python Data Structures
(lists and dictionaries)

2.6 Lists

# timeit.Timer
def test1():
    alist = [i for i in range(1000)]

t1 = Timer("test1()", "from __main__ import test1")
t1.timeit(number=100)

indexing and assigning        O(1)
append                        O(1)
concatenate a list of size k  O(k)  # alist += [i]
pop()                         O(1)
pop(i)                        O(n)
insert(i, item)				  O(n)
del							  O(n)
contains (in)  				  O(n)
slice						  O(n)
reverse						  O(n)
sort						  O(n log n)
multiply					  O(nk)

2.7 Dictionaries

You access dictionary items by a key, while in lists, it is done by index (its position)

get			   O(1) \
set            O(1)  > Average performance
contains (in)  O(1) /
copy           O(n)
delete         O(1)
iteration      O(n)

3.1 Objectives
- Cover the abstract data types
    stack, queue, deque, list

- prefix, infix, postfix expression formats
    - use stacks for these expression formats

- use queues for timing simulations

- use the node and reference pattern for linked lists

3.2 Linear data structures are collections where items stay in the same place relative to others that were added or removed.

  left/front [][][][][][] right/rear

3.3 In a stack, addition and removal takes place at the same end--the top

The opposite end is called the base, and represent items that have been there the longest.

Stack ordering is called LIFO (Last-In, First-Out)

By stacking items, then removing them one at a time to a new stack, order is reversed

Analogy: Browser history. The back button removes the newest URL

3.4 The Stack Abstract Data Type

Stack() creates an empty stack
push(item) adds item to the top of the stack
pop() removes and returns the top item
peek() returns the top item but does not remove it
isEmpty() tests whether the stack is empty
size() returns the number of items on the stack

3.5 Implementing a stack

class Stack:
    def __init__(self):
	    self.items = []

	def isEmpty(self):
	    return self.items == []

	def push(self, item):
		self.items.append(item)

	def pop(self):
		return self.items.pop()

	def peek(self):
		return self.items[-1]

	def size(self):
		return len(self.items)

Though the implementation could have placed the stack's top to the left end of the 'items' list, the performance will be O(n) instead of O(1)

Example: reverse a string by using a stack

3.6 Simple balanced parentheses

Closing symbols match opening symbols in the reverse order of their appearance.

In the algorithm, we initialize 'balanced' to be True; there is no reason to assume otherwise.

At the end, the stack should be empty

3.7 Balanced brackets

In the general case, we must check that a closing bracket matches the type of the opening bracket on top of the stack

3.8 Converting decimal numbers to any base from 2 to 9
(the text covers binary)

[Rosen p. 249]
def changeBase(n, base):
	digits = []
	while n > 0:
		digits.append(n % base)
		n //= base
	return ''.join(map(str, digits[::-1]))

for bases above 9, we define a string (a list) of valid digits
validDigits = "0123456789ABCDEF"
... digits.append(validDigits[n % base])

3.9 Infix, prefix, postfix

A + B * C is infix, but operators have different precedence levels to remove ambiguity in the order of operations

Prefix notation requires that all operators precede (come before) operands. + A B

Postfix requires that operators come after the operands. A B +. Reverse Polish Notation (RPN) is postfix.

infix         prefix      postfix
(A + B) * C   * + A B C   A B + C *

In order to convert infix to prefix or postfix, fully parenthesize the infix expression, then move the enclosed operator to either the left parenthesis (for prefix) or the right one (for postfix).

In the general algorithm for infix to postfix, we use a stack to store the operators.

1. Create a stack for operators 'opstack'
2. Split the input string (in infix)
3. Scan the token list from left to right
   - if it's an operand, append it to the end of the output list
   - if it's a left paren, push it on the opstack
   - if it's a right paren, pop all operators, appending them to the output, until the corresponding left paren appears.
   - if it's an operator, first remove operators already on the opstack of higher or equal precedence. Then push it on the opstack
4. Any remaining operators can be removed and appended to the end of the output list.

prec = {}  # holds precedence levels of operators
prec['*'] = 3
prec['/'] = 3
prec['+'] = 2
prec['-'] = 2
prec['('] = 1
prec[')'] = 1

3.9.3 Postfix Evaluation

1. Create an empty stack 'operandStack'
2. Split the input string
3. Scan the token list from left to right:
   - if it's an operand, push it on the operand stack
   - if it's an operator, pop the operandStack twice. The first pop is the second operand, and the second pop is the first operand. Push the result back on the operandStack.
4. The result is the value on the operandStack. Pop and return it.

3.10 Queues

A queue is an ordered collection of items where the addition of new items happens at one end, the "rear", and removal at the other end, the "front".

The most recently added item must wait, while the item that has been in the collection the longest is at the front.

This ordering principle is called FIFO (First-In, First-Out)

Examples: print tasks, operating system scheduling

3.11 The Queue Abstract Data Type

Queue() creates a new queue
enqueue(item) adds item to the rear
dequeue() removes and returns the front item
isEmpty() tests to see whether the queue is empty
size() returns the number of items in the queue

q = Queue()       []
q.enqueue(4)      [4]
q.enqueue('dog')  ['dog', 4]
q.dequeue()       ['dog']         => returns 4
              rear          front

3.12 Implementing a queue

# pythonds.basic.queue

class Queue:
    def __init__(self):
	    self.items = []

	def isEmpty(self):
		return self.items == []

	def enqueue(self, item):
		self.items.insert(0, item)

	def dequeue(self):
		return self.items.pop()

	def size(self):
		return len(self.items)

3.13 Hot Potato (Josephus problem)

A queue acts as a circle, where the front person passes the potato to the person behind, is dequeued, and immediately enqueued (going to the rear of the queue). After 'num' passes of the potato, the front person is removed.

3.14 Printing Tasks

Simulate 10 students printing twice a paper of length between 1 and 20 pages.

Create classes for Printer, Task, and PrintQueue, 'tick' to decrement the internal timer.

3.15 What is a deque?

A deque is a "double-ended queue" and is structurally similar to a queue--it has a front and a rear. However, items may be added and removed from either end.

(StackOverflow) A deque is a doubly-linked list

A deque provides all the capabilities of stacks and queues in a single data structure

3.16 The Deque Abstract Data Type

Deque() creates a new deque
addFront(item)     [..., ...]
addRear(item)     rear    front
removeFront()
removeRear()
isEmpty()
size()

collections.deque has:
appendleft()  append()
popleft()     pop()

3.17 Implementing a Deque

...
def addFront(self, item):
    self.items.append(item)  # right end

def addRear(self, item):
    self.items.insert(0, item)  # left end

def removeFront(self):
    return self.items.pop()

def removeRear(self):
    return self.items.pop(0)

3.18 Palindrome Checker

Place word in a deque. While size > 1, remove both the front and rear characters. If they are not the same, the word is not a palindrome

3.19 Lists

A list is a collection of items where each item holds a relative position with respect to the others (first item, second item, third item, and so on). We assume here that lists don't have duplicates.

A list may be ordered or unordered. In an ordered list, the items' values are arranged either in ascending or descending order (sec. 3.22)

3.20 The Unordered List Abstract Data Type

List()
add(item) Adds item as the new head. Assume item is not already there
remove(item) We are assuming there are no duplicates
search(item) returns a Boolean
isEmpty()
size()
append(item) adds item to the end
index(item) assumes the item is in the list
insert(pos, item)
pop() removes and returns the last item
pop(pos)

3.21 Implementing an Unordered List with Linked Lists

The location of the first item of a linked list must be explicitly specified. This external reference is called the "head" of the list.

The first item knows where the second item is. The second knows the third, and so on. The last item needs to know there is no next item.

The basic building block is the "node". It contains the list item itself in the "data field". It also holds a reference to the next node.

class Node:
	def __init__(self, initdata):
		self.data = initdata
		self.next = None

	... getData(), setData()
	getNext(), setNext()

-||| (grounding the node) indicates None, the end of the list

3.21.2 The Unordered List Class

Each list object will maintain a single reference to the head of the list.

mylist   head
  []--->( [] )--->|||

mylist   head
  []--->( [] )--->[54| ]--->[26| ]--->[12| ]--->|||

The list class itself does not contain Node objects. Instead, it contains a single reference to only the first node in the linked structure.

isEmpty() checks if the head is None

Adding items is easiest at the head.

def add(self, item):
	temp = Node(item)
	temp.setNext(self.head)
	self.head = temp

size, search and remove are implemented with "linked list traversal" (systematically visiting each node). An external reference that starts at the first node is used ("current")

For searching, we initialize "found" to False

remove() assumes the item is present. Two external references, "previous" and "current", are needed, because "previous"'s next needs to become "current"'s next. "previous" starts as None

In traversing, "previous" must be moved forward first (this process is called "inch-worming")

If the item to be removed is at the head, a special procedure is needed because "previous" is None. Head is set to current's next.

append, insert, index and pop are not shown.

3.22 The Ordered List Abstract Data Type

in ascending order, a list may be [17, 26, 31, 54, 79, 93]

The relative position of each item is based upon some underlying characteristic of the item

OrderedList()
add(item) makes sure order is preserved
remove(item)
search(item) returns a Boolean
isEmpty(), size()
index(item)
pop()
pop(pos)

3.23 Implementing an Ordered List

initializing, isEmpty, size and remove are the same as Unordered List

In searching, we may take advantage of the ordering to stop after the searched value is passed. For example, searching for 45 in [17, 26, 31, 54, 77, 93] can stop once 54 is reached.

in search(), initialize another Boolean, "stop", to False

when adding an item, the method must decide which two items will surround the new item.

Seeing a value greater than 'item' will cause us to stop.

3.23.1 Analysis of Linked Lists

If traversal is needed (length, size, search, remove) and insert and add in ordered lists, the complexity is O(n)

Adding at the head (in unordered lists) and isEmpty() is O(1)

4.1 Recursion - Objectives

complex problems that may otherwise be difficult to solve may have a simple recursive solution

4.2 What is Recursion?

Recursion is a method of solving problems that involves breaking them down into smaller and smaller subproblems until you get to a small enough problem that can be solved trivially.

Usually recursion involves a function calling itself.

4.3 Calculating the Sum of a List

How would you add a list of numbers without 'for' or 'while' loops?

Addition is defined for a pair of numbers. We may add parentheses and sequentially add numbers

total = (1 + (3 + (5 + (7 + 9))))
      = (1 + (3 + (5 + 16)))
	  = (1 + (3 + 21))
	  = (1 + 24)
	  = 25

listSum(numList) = first(numList) + listSum(rest(numList))

if len(numList) == 1:
	return numList[0]
else:
	return numList[0] + listSum(numList[1:])

The check for a list of size 1 is our "escape clause". The sum of a list of size 1 is trivial: the number in the list

When we reach the point where the problem is as simple as it can get, we begin to piece together the solutions of each of the small problems until the initial problem is solved.

4.4 The 3 laws of recursion

1. A recursive algorithm must have a base case
2. A recursive algorithm must change its state and move toward the base case
3. A recursive algorithm must call itself, recursively

The base case is the condition that allows the algorithm to stop recursing (a trivial case that may be solved directly).

Usually the data gets smaller in some way when a recursive call is made.

A recursive factorial function should have n <= 1 as its base case (the factorial of zero is 1 and the program would not crash with negative inputs)

4.5 Converting an integer to a string in any base

Alternative algorithm to using a stack.

Use integer division to reduce the number and concatenate the remainder.

def convBase(n, base):
	convStr = "0123456789ABCDEF"
	if n < base:
		return convStr[n]
	else:
		return convBase(n // base, base) + convStr[n % base]

4.6 Stack Frames: Implementing recursion

Instead of concatenating the result of the recursive call in the base conversion algorithm, we could use a stack to store the digits.

When a function is called, a stack frame is allocated to handle the function's local variables.

In list summing, you can think of the return value on the stack taking the place of an accumulator variable.

A stack frame also provides a scope for the function's variables. Each call creates a new scope.

4.7 Visualizing recursion

Turtle graphics: move forward, backward, turn left, right, pen up, pen down

draw a spiral by recursively drawing shorter and shorter line segments and turning right

+--------+
| +----+ |
| | +- | |
| | +--+ |
| +------+
 
A fractal has the same basic shape no matter how much you magnify it (snowflakes, coastlines, trees)

In drawing a tree, we make sure to decrease the size of branches so that the recursion ends.

def tree(branchLen, t):  # t is turtle
	if branchLen > 5:
		t.forward(branchLen)
		t.right(20)
		tree(branchLen-15, t)
		t.left(40)
		tree(branchLen-10, t)
		t.right(20)
		t.backward(branchLen)

the tree is drawn all the way to the right first.

