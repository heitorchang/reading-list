https://runestone.academy/runestone/static/pythonds/index.html

Problem Solving with Algorithms and Data Structures using Python

1.1 Problem solving, abstraction, abstract data types

1.2 Review the framework within which computer science and the study of algorithms and data structures must fit

1.3 Computers are just tools

An algorithm is a step-by-step list of instructions for solving any instance of a problem that might arise. They are finite and give solutions.

A problem is computable if there is an algorithm to solve it. Computer Science studies both solvable and unsolvable problems

Abstraction separates logical and physical perspectives. For example, the functions of a car from a logical perspective is braking, steering and accelerating. Such functions are called the interface. The user is called the client.

The car's physical perspective is of interest to a mechanic. He must know how the engine works (details "under the hood").

Procedural abstraction is separating the interface from its implementation. We can call math.sqrt without knowing how it works.

1.4 Programming is the process of taking an algorithm and encoding it into a language's notation that is understood by a computer.

Control constructs such as sequential processing, decision making and iteration allow representation of algorithmic steps unambiguously

Data types provide an interpretation of raw binary data. They are also called "Primitive data types" (for example, integers)

1.5 Abstractions help manage the complexity of problems.

An Abstract Data Type (ADT) is a logical description of how we view the data and apply operations without regard to how it will be implemented.

This level of abstraction creates an encapsulation around the data (also called information hiding)

The implementation (physical view) of an ADT is a data structure

The separation of logical and physical views allow an implementation-independent view of the data

1.6 By seeing how algorithms are designed, we can develop pattern recognition.

There will often be trade-offs we need to identify and decide upon.

1.7 Python is an interpreted, object-oriented programming language. It considers data to be the focal point of the problem-solving process

1.8 A class is a description of what the data looks like (the state) and what they can do (the behavior). A class is analogous to an Abstract Data Type.

Data items are called objects (instances of a class)

1.8.1 Built-in Atomic Data Types

numeric: int, float
arithmetic: +, -, *, /, **, %, //
boolean: True, False, and, not
<, >, <=, >=, ==, !=

Assignment (theSum = 0) associates a name with a value. The variable will hold a reference to a piece of data and not the data itself.

(Stack Overflow) ints are immutable, so when changing the value of a local variable (inside a function), a new integer object is created.

Re-assignment inside a function moves the reference to a new object, while changes to a mutable object (alist[0] = 0) does not change the alist reference itself.

Python is dynamic: the same variable can refer to many different types of data

1.8.2 Built-in Collection data Types

Ordered: List, String, Tuple
Unordered: Dictionary, Set

Lists are heterogeneous (elements need not be of the same class)

List Operations
indexing      [i]
concatenation +
repetition    *
membership    in
length        len()
slicing       [a:b:step]

Indices start counting with 0. Slice index a is included, but b is not.

When repeating a list, the references are copied. So a repeated nested list is the same list. Changing it in one place will affect all other copies.

List methods

alist.append(item)
.insert(i, item) inserts item into the ith position
.pop(), .pop(i)
.sort(), .reverse()
.index(item)
.count(item)
.remove(item) removes the first occurrence of item
del alist[i]

list(range(5, 10, 2)) => [5, 7, 9]

String methods
(sequence operations also work)
Alignment: center, ljust, rjust
Case: upper, lower, swapcase, title
count, find, rfind, index, rindex

find vs. index
s.index('a') will raise ValueError if it doesn't find the argument
find returns -1
Mnemonic: -1 is not found, you can't say not index. Also, -1 is the last character.

split uses the argument as division points or whitespace if there are no arguments.

Lists are mutable, strings and tuples are not.

Sets do not allow duplicates.
The empty set is set()
a | b Union (all elements from both sets)
a & b Intersection (elements common to both)
a - b Difference (elements in a but not in b)
a <= b Asks whether all elements of a are in b (isSubset)

add, remove, pop, clear
pop removes an arbitrary element from the set

Dictionaries are collections of associated pairs of keys and values

capitals = {'Iowa': 'Des Moines', 'Wisconsin', 'Madison'}
capitals['California'] = 'Sacramento'

list(adict) returns the keys

keys, values, and items return objects. They may be converted to lists.

adict.get('akey', 'not found') returns the value associated to 'akey' or 'not found' if that key is not present. Without the second argument, .get() returns None if the key is not found.

1.9

aName = input('Please enter your name: ')
input() returns a string
in Python 2, use raw_input()

use float() or int() to convert to numbers

print(a, b, c, sep="***", end="!!\n")

formatted string
print("%s is %d years old." % (aName, age))

there is a .format() method not covered in this book

1.10 Control Structures
counter = 1
while counter <= 5:
    print(counter, end=" ")
	counter += 1

=> 1 2 3 4 5

and, or are short-circuit operators

for item in [1, 3, 6, 5, 0]:

for i in range(5):

for aletter in aword:

if ... else
if ... elif ... elif ... else

[Internet] 'else' at the end of for and while loops are executed if the loop completes (is not interrupted by break, for example)

list comprehension: add 10 to odd integers
[x + 10 for x in range(10) if x % 2 == 1]
=> [11, 13, 15, 17, 19]

a = [1, 1, 0]
['T' if n == 1 else 'F' for n in a]
=> ['T', 'T', 'F']

1.11 Exception Handling

A syntax error occurs when there's a mistake in the structure of a statement or expression

[PyRef] A simple statement is comprised within a single logical line

Expression statements are mostly used interactively, to compute and write a value or to call a procedure

a logic error occurs when the program executes but gives the wrong result. If a situation such as division by zero or list access out of bounds occurs at runtime, it is called an exception

Exceptions are raised and handled

try ... except blocks are used to handle potential exceptions. The except block "catches" the exception.

The programmer can raise his or her own exceptions

raise RuntimeError("can't use negative numbers")

1.12 Defining Functions

A function hides the details of a computation

A function definition requires a name, a group of parameters, and a body. It may explicitly return a value

(an argument is a value given to a function; try 's'.join(). It raises TypeError: join takes exactly one argument (0 given))

Newton's method for square roots:
newguess = (1/2) * (oldguess + (n / oldguess))

1.13 Defining classes

A programmer may create new classes to model data that is needed to solve the problem.

To implement an abstract data type, we use a new class.

1.13.1 Fraction

3 (numerator)
- 
5 (denominator)

class Fraction:
    def __init__(self, top, bottom):
	    self.num = top
		self.den = bottom

self is a special parameter that is used as a reference back to the object itself.

'self' must always be the first formal parameter

To create an instance, we invoke the constructor:
myFraction = Fraction(3, 5)

we want to override the __str__ method to get an useful result with print().

[Fluent Py] __repr__ should be "as-code"
    return "Fraction({}, {})".format(self.num, self.den)

override __add__ method

Euclid's algorithm for GCD
[sicp]

def gcd(a, b):
    if b == 0:
	    return a
	return gcd(b, a % b)

In this Fraction implementation, a negative fraction will have a negative numerator.

shallow equality is when two references (variables) refer to the same object

deep equality is when two distinct objects have the same value (not the same reference). __eq__ and __le__ may be overridden.

1.13.2 Inheritance: Logic gates and circuits

Inheritance is the ability for one class to be related to another. Child classes can inherit characteristic data and behavior from a parent class

Child classes are called subclasses and parents are called superclasses. A child and parent follow a "is-a relationship".

The most general class for the digital circuit simulation is LogicGate

The general LogicGate class uses performGateLogic, which will be implemented by subclasses.

class UnaryGate(LogicGate):
	def __init__(self, n):
    	super().__init__(n)
		# Or super(UnaryGate, self).__init__(n)
		LogicGate.__init__(self, n)

Child class constructors need to call parent class constructors and then move on to their distinguishing data.

The connector class is not part of the gate hierarchy, but follows a "has-a" relationship. A connector has two gates. "Has-a" does not involve inheritance.

2.1 Analysis

Big-O execution time of common list and dictionary operations

2.2 How do we decide one program is better than another?

There may be many programs for the same algorithm

Algorithm analysis is concerned with comparing the amount of computing resources (time and memory) each algorithm uses

Benchmarking actual time to run an algorithm is not really useful because it is dependent on a particular machine, program, and language

def sumOfN(n):
    start = time.time()
	theSum = ...
	end = time.time()
	return theSum, end - start

2.3 Big-O notation

To characterize efficiency independent of a particular program or computer, it is important to quantify the number of operations.

For a function T(n) denoting the number of operations (such as assignment), the most dominant part is the "order of magnitude" function, O(f(n)). f(n) is a simple representation of the dominant part of T(n).

For algorithms that depend on the exact values of the data, we may characterize their performance in terms of best case, worst case, or average case

common orders of magnitude are:

f(n)     name
1        constant
log n    logarithmic
n        linear
n log n  log linear
n^2      quadratic
n^3      cubic
2^n      exponential
n!       factorial

2.4 Check if two strings are anagrams

2.4.1 "check off" characters from the first string by replacing characters in a list (converted from the second string) with None as they are seen. It is O(n^2)

2.4.2 Sort and compare
Sort both strings alphabetically and compare them. Its time complexity depends on the sorting algorithm used, typically O(n log n)

2.4.3 Brute force (exhaust all possibilities)
There are n characters for the first position, n-1 for the second, and so on. It is O(n!)

2.4.4 Count and compare
Use a list of 26 counters, each for a possible letter. Then compare the two lists. This algorithm is O(n) but requires additional storage. It sacrifices space in order to gain time

2.5 Performance of Python Data Structures
(lists and dictionaries)

2.6 Lists

# timeit.Timer
def test1():
    alist = [i for i in range(1000)]

t1 = Timer("test1()", "from __main__ import test1")
t1.timeit(number=100)

indexing and assigning        O(1)
append                        O(1)
concatenate a list of size k  O(k)  # alist += [i]
pop()                         O(1)
pop(i)                        O(n)
insert(i, item)				  O(n)
del							  O(n)
contains (in)  				  O(n)
slice						  O(n)
reverse						  O(n)
sort						  O(n log n)
multiply					  O(nk)

2.7 Dictionaries

You access dictionary items by a key, while in lists, it is done by index (its position)

get			   O(1) \
set            O(1)  > Average performance
contains (in)  O(1) /
copy           O(n)
delete         O(1)
iteration      O(n)

3.1 Objectives
- Cover the abstract data types
    stack, queue, deque, list

- prefix, infix, postfix expression formats
    - use stacks for these expression formats

- use queues for timing simulations

- use the node and reference pattern for linked lists

3.2 Linear data structures are collections where items stay in the same place relative to others that were added or removed.

  left/front [][][][][][] right/rear

3.3 In a stack, addition and removal takes place at the same end--the top

The opposite end is called the base, and represent items that have been there the longest.

Stack ordering is called LIFO (Last-In, First-Out)

By stacking items, then removing them one at a time to a new stack, order is reversed

Analogy: Browser history. The back button removes the newest URL

