https://runestone.academy/runestone/static/pythonds/index.html

Problem Solving with Algorithms and Data Structures using Python

1.1 Problem solving, abstraction, abstract data types

1.2 Review the framework within which computer science and the study of algorithms and data structures must fit

1.3 Computers are just tools

An algorithm is a step-by-step list of instructions for solving any instance of a problem that might arise. They are finite and give solutions.

A problem is computable if there is an algorithm to solve it. Computer Science studies both solvable and unsolvable problems

Abstraction separates logical and physical perspectives. For example, the functions of a car from a logical perspective is braking, steering and accelerating. Such functions are called the interface. The user is called the client.

The car's physical perspective is of interest to a mechanic. He must know how the engine works (details "under the hood").

Procedural abstraction is separating the interface from its implementation. We can call math.sqrt without knowing how it works.

1.4 Programming is the process of taking an algorithm and encoding it into a language's notation that is understood by a computer.

Control constructs such as sequential processing, decision making and iteration allow representation of algorithmic steps unambiguously

Data types provide an interpretation of raw binary data. They are also called "Primitive data types" (for example, integers)

1.5 Abstractions help manage the complexity of problems.

An Abstract Data Type (ADT) is a logical description of how we view the data and apply operations without regard to how it will be implemented.

This level of abstraction creates an encapsulation around the data (also called information hiding)

The implementation (physical view) of an ADT is a data structure

The separation of logical and physical views allow an implementation-independent view of the data

1.6 By seeing how algorithms are designed, we can develop pattern recognition.

There will often be trade-offs we need to identify and decide upon.

1.7 Python is an interpreted, object-oriented programming language. It considers data to be the focal point of the problem-solving process

1.8 A class is a description of what the data looks like (the state) and what they can do (the behavior). A class is analogous to an Abstract Data Type.

Data items are called objects (instances of a class)

1.8.1 Built-in Atomic Data Types

numeric: int, float
arithmetic: +, -, *, /, **, %, //
boolean: True, False, and, not
<, >, <=, >=, ==, !=

Assignment (theSum = 0) associates a name with a value. The variable will hold a reference to a piece of data and not the data itself.

(Stack Overflow) ints are immutable, so when changing the value of a local variable (inside a function), a new integer object is created.

Re-assignment inside a function moves the reference to a new object, while changes to a mutable object (alist[0] = 0) does not change the alist reference itself.

Python is dynamic: the same variable can refer to many different types of data

1.8.2 Built-in Collection data Types

Ordered: List, String, Tuple
Unordered: Dictionary, Set

Lists are heterogeneous (elements need not be of the same class)

List Operations
indexing      [i]
concatenation +
repetition    *
membership    in
length        len()
slicing       [a:b:step]

Indices start counting with 0. Slice index a is included, but b is not.

When repeating a list, the references are copied. So a repeated nested list is the same list. Changing it in one place will affect all other copies.

List methods

alist.append(item)
.insert(i, item) inserts item into the ith position
.pop(), .pop(i)
.sort(), .reverse()
.index(item)
.count(item)
.remove(item) removes the first occurrence of item
del alist[i]

list(range(5, 10, 2)) => [5, 7, 9]

String methods
(sequence operations also work)
Alignment: center, ljust, rjust
Case: upper, lower, swapcase, title
count, find, rfind, index, rindex

find vs. index
s.index('a') will raise ValueError if it doesn't find the argument
find returns -1
Mnemonic: -1 is not found, you can't say not index. Also, -1 is the last character.

split uses the argument as division points or whitespace if there are no arguments.

Lists are mutable, strings and tuples are not.

Sets do not allow duplicates.
The empty set is set()
a | b Union (all elements from both sets)
a & b Intersection (elements common to both)
a - b Difference (elements in a but not in b)
a <= b Asks whether all elements of a are in b (isSubset)

add, remove, pop, clear
pop removes an arbitrary element from the set

Dictionaries are collections of associated pairs of keys and values

capitals = {'Iowa': 'Des Moines', 'Wisconsin', 'Madison'}
capitals['California'] = 'Sacramento'

list(adict) returns the keys

keys, values, and items return objects. They may be converted to lists.

adict.get('akey', 'not found') returns the value associated to 'akey' or 'not found' if that key is not present. Without the second argument, .get() returns None if the key is not found.

1.9

aName = input('Please enter your name: ')
input() returns a string
in Python 2, use raw_input()

use float() or int() to convert to numbers

print(a, b, c, sep="***", end="!!\n")

formatted string
print("%s is %d years old." % (aName, age))

there is a .format() method not covered in this book

1.10 Control Structures
counter = 1
while counter <= 5:
    print(counter, end=" ")
	counter += 1

=> 1 2 3 4 5

and, or are short-circuit operators

for item in [1, 3, 6, 5, 0]:

for i in range(5):

for aletter in aword:

if ... else
if ... elif ... elif ... else

[Internet] 'else' at the end of for and while loops are executed if the loop completes (is not interrupted by break, for example)

list comprehension: add 10 to odd integers
[x + 10 for x in range(10) if x % 2 == 1]
=> [11, 13, 15, 17, 19]

a = [1, 1, 0]
['T' if n == 1 else 'F' for n in a]
=> ['T', 'T', 'F']

1.11 Exception Handling

A syntax error occurs when there's a mistake in the structure of a statement or expression

[PyRef] A simple statement is comprised within a single logical line

Expression statements are mostly used interactively, to compute and write a value or to call a procedure

a logic error occurs when the program executes but gives the wrong result. If a situation such as division by zero or list access out of bounds occurs at runtime, it is called an exception

Exceptions are raised and handled

try ... except blocks are used to handle potential exceptions. The except block "catches" the exception.

The programmer can raise his or her own exceptions

raise RuntimeError("can't use negative numbers")

1.12 Defining Functions
