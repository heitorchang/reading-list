https://runestone.academy/runestone/static/pythonds/index.html

Problem Solving with Algorithms and Data Structures using Python

1.1 Problem solving, abstraction, abstract data types

1.2 Review the framework within which computer science and the study of algorithms and data structures must fit

1.3 Computers are just tools

An algorithm is a step-by-step list of instructions for solving any instance of a problem that might arise. They are finite and give solutions.

A problem is computable if there is an algorithm to solve it. Computer Science studies both solvable and unsolvable problems

Abstraction separates logical and physical perspectives. For example, the functions of a car from a logical perspective is braking, steering and accelerating. Such functions are called the interface. The user is called the client.

The car's physical perspective is of interest to a mechanic. He must know how the engine works (details "under the hood").

Procedural abstraction is separating the interface from its implementation. We can call math.sqrt without knowing how it works.

1.4 Programming is the process of taking an algorithm and encoding it into a language's notation that is understood by a computer.

Control constructs such as sequential processing, decision making and iteration allow representation of algorithmic steps unambiguously

Data types provide an interpretation of raw binary data. They are also called "Primitive data types" (for example, integers)

1.5 Abstractions help manage the complexity of problems.

An Abstract Data Type (ADT) is a logical description of how we view the data and apply operations without regard to how it will be implemented.

This level of abstraction creates an encapsulation around the data (also called information hiding)

The implementation (physical view) of an ADT is a data structure

The separation of logical and physical views allow an implementation-independent view of the data

1.6 By seeing how algorithms are designed, we can develop pattern recognition.

There will often be trade-offs we need to identify and decide upon.

1.7 Python is an interpreted, object-oriented programming language. It considers data to be the focal point of the problem-solving process

1.8 A class is a description of what the data looks like (the state) and what they can do (the behavior). A class is analogous to an Abstract Data Type.

Data items are called objects (instances of a class)

1.8.1 Built-in Atomic Data Types

numeric: int, float
arithmetic: +, -, *, /, **, %, //
boolean: True, False, and, not
<, >, <=, >=, ==, !=

Assignment (theSum = 0) associates a name with a value. The variable will hold a reference to a piece of data and not the data itself.

(Stack Overflow) ints are immutable, so when changing the value of a local variable (inside a function), a new integer object is created.

Re-assignment inside a function moves the reference to a new object, while changes to a mutable object (alist[0] = 0) does not change the alist reference itself.

Python is dynamic: the same variable can refer to many different types of data

1.8.2 Built-in Collection data Types

Ordered: List, String, Tuple
Unordered: Dictionary, Set

Lists are heterogeneous (elements need not be of the same class)

List Operations
indexing      [i]
concatenation +
repetition    *
membership    in
length        len()
slicing       [a:b:step]

Indices start counting with 0. Slice index a is included, but b is not.

When repeating a list, the references are copied. So a repeated nested list is the same list. Changing it in one place will affect all other copies.

List methods

alist.append(item)
.insert(i, item) inserts item into the ith position
.pop(), .pop(i)
.sort(), .reverse()
.index(item)
.count(item)
.remove(item) removes the first occurrence of item
del alist[i]

list(range(5, 10, 2)) => [5, 7, 9]

String methods
(sequence operations also work)
Alignment: center, ljust, rjust
Case: upper, lower, swapcase, title
count, find, rfind, index, rindex

find vs. index
s.index('a') will raise ValueError if it doesn't find the argument
find returns -1
Mnemonic: -1 is not found, you can't say not index. Also, -1 is the last character.

split uses the argument as division points or whitespace if there are no arguments.

Lists are mutable, strings and tuples are not.

Sets do not allow duplicates.
The empty set is set()
a | b Union (all elements from both sets)
a & b Intersection (elements common to both)
a - b Difference (elements in a but not in b)
a <= b Asks whether all elements of a are in b (isSubset)

add, remove, pop, clear
pop removes an arbitrary element from the set

Dictionaries are collections of associated pairs of keys and values

capitals = {'Iowa': 'Des Moines', 'Wisconsin', 'Madison'}
capitals['California'] = 'Sacramento'

list(adict) returns the keys

keys, values, and items return objects. They may be converted to lists.

adict.get('akey', 'not found') returns the value associated to 'akey' or 'not found' if that key is not present. Without the second argument, .get() returns None if the key is not found.

1.9

aName = input('Please enter your name: ')
input() returns a string
in Python 2, use raw_input()

use float() or int() to convert to numbers

print(a, b, c, sep="***", end="!!\n")

formatted string
print("%s is %d years old." % (aName, age))

there is a .format() method not covered in this book

1.10 Control Structures
counter = 1
while counter <= 5:
    print(counter, end=" ")
	counter += 1

=> 1 2 3 4 5

and, or are short-circuit operators

for item in [1, 3, 6, 5, 0]:

for i in range(5):

for aletter in aword:

if ... else
if ... elif ... elif ... else

[Internet] 'else' at the end of for and while loops are executed if the loop completes (is not interrupted by break, for example)

list comprehension: add 10 to odd integers
[x + 10 for x in range(10) if x % 2 == 1]
=> [11, 13, 15, 17, 19]

a = [1, 1, 0]
['T' if n == 1 else 'F' for n in a]
=> ['T', 'T', 'F']

1.11 Exception Handling

A syntax error occurs when there's a mistake in the structure of a statement or expression

[PyRef] A simple statement is comprised within a single logical line

Expression statements are mostly used interactively, to compute and write a value or to call a procedure

a logic error occurs when the program executes but gives the wrong result. If a situation such as division by zero or list access out of bounds occurs at runtime, it is called an exception

Exceptions are raised and handled

try ... except blocks are used to handle potential exceptions. The except block "catches" the exception.

The programmer can raise his or her own exceptions

raise RuntimeError("can't use negative numbers")

1.12 Defining Functions

A function hides the details of a computation

A function definition requires a name, a group of parameters, and a body. It may explicitly return a value

(an argument is a value given to a function; try 's'.join(). It raises TypeError: join takes exactly one argument (0 given))

Newton's method for square roots:
newguess = (1/2) * (oldguess + (n / oldguess))

1.13 Defining classes

A programmer may create new classes to model data that is needed to solve the problem.

To implement an abstract data type, we use a new class.

1.13.1 Fraction

3 (numerator)
- 
5 (denominator)

class Fraction:
    def __init__(self, top, bottom):
	    self.num = top
		self.den = bottom

self is a special parameter that is used as a reference back to the object itself.

'self' must always be the first formal parameter

To create an instance, we invoke the constructor:
myFraction = Fraction(3, 5)

we want to override the __str__ method to get an useful result with print().

[Fluent Py] __repr__ should be "as-code"
    return "Fraction({}, {})".format(self.num, self.den)

override __add__ method

Euclid's algorithm for GCD
[sicp]

def gcd(a, b):
    if b == 0:
	    return a
	return gcd(b, a % b)

In this Fraction implementation, a negative fraction will have a negative numerator.

shallow equality is when two references (variables) refer to the same object

deep equality is when two distinct objects have the same value (not the same reference). __eq__ and __le__ may be overridden.

1.13.2 Inheritance: Logic gates and circuits

Inheritance is the ability for one class to be related to another. Child classes can inherit characteristic data and behavior from a parent class

Child classes are called subclasses and parents are called superclasses. A child and parent follow a "is-a relationship".

The most general class for the digital circuit simulation is LogicGate

The general LogicGate class uses performGateLogic, which will be implemented by subclasses.

class UnaryGate(LogicGate):
	def __init__(self, n):
    	super().__init__(n)
		# Or super(UnaryGate, self).__init__(n)
		LogicGate.__init__(self, n)

Child class constructors need to call parent class constructors and then move on to their distinguishing data.

The connector class is not part of the gate hierarchy, but follows a "has-a" relationship. A connector has two gates. "Has-a" does not involve inheritance.

2.1 Analysis
