53 in Jupyter, run "%matplotlib inline" to integrate it properly

58 isinstance(a, int)
58 isinstance(a, (int, float))

59 getattr(a, 'split')

66 o caractere \ é um "caractere de escape". barras invertidas precisam ser escapadas.

71 datetime_obj.replace(minute=0, second=0)

85 to add multiple elements to a list, use .extend() instead of +

88 map items' location in a list

mylist = ['foo', 'bar', 'baz']
mapping = {}
for i, e in enumerate(mylist):
    mapping[e] = i
# mapping: {'bar': 1, 'baz': 2, 'foo': 0}

also (p. 98):
loc_mapping = {val: index for index, val in enumerate(mylist)}

90 convert lines to columns

pitchers = [('Nolan', 'Ryan'), ('Roger', 'Clemens')]
first_names, last_names = zip(*pitchers)

92 mydict.update({'b': 'foo', 'c': 12}) alters mydict in-place

92 dict() accepts a list of tuples (pairs)

93 words = ['apple', 'bat', 'bar', 'atom', 'book']
by_letter = {}
for word in words:
    letter = word[0]
    by_letter.setdefault(letter, []).append(word)

also: defaultdict
by_letter = defaultdict(list)

99 some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
flattened = [x for tup in some_tuples for x in tup]
# [1, 2, 3, 4, 5, 6, 7, 8, 9]

compare to:

[[x for x in tup] for tup in some_tuples]
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

the order of nested list comprehensions is the same as nested for blocks

100 funções são declaradas com a palavra reservada def, e o retorno é feito com return.

102 funções "devolvem" valores

109 first_letter = lambda x: x[0]
itertools.groupby(names, first_letter)

111 handle multiple exceptions:
try:
    return float(x)
except (ValueError, TypeError):
    return x
 
114 open mode 'x' will fail if the file already exists

Ch. 4 NumPy

122 ndarray é um objeto array N-dimensional

123 data = np.random.randn(2, 3)  # generates 2 rows and 3 columns of random numbers

simply write "data * 2" or "data + data"

data.shape()  # (2, 3)
data.dtype  # dtype('float64')
data.ndim  # 2

124 creating ndarrays

data1 = [6, 7.5, 8, 1, 0]
arr1 = np.array(data1)

125 np.zeros(10)
np.zeros((3, 6))
np.empty((2, 3, 2))  # WARNING: might contain junk values

np.arange(15) is the analogous function to regular "range"

126 np.asarray(arr) does not make a copy if arr is already a ndarray

128 cast an array:
float_arr = arr.astype(np.float64)

WARNING: the dtype numpy.string_ and unicode_ have fixed length and data may be truncated (for example, when an element is changed in-place)

129 bulk, element-by-element arithmetic without loops is called "vectorization"

131 array slices are views (data is not copied)

132 to copy a slice: arr[5:8].copy()

132 in a 2-d array, arr[0][2] is the same as arr[0, 2]. the first index is the row and the second index is the column

134 n-dimensional arrays can be sliced: arr[:2, 1:]. Use the comma syntax [:2, :1]

136 boolean indexing: data[names == 'Bob'] WARNING: if the boolean array dimension does not match the target array, no error is raised

138 ~ (not), & and | can be used to combine boolean conditions. "and", "or" will not work
WARNING: copies are always made with boolean indexing

139 data[data < 0] = 0

140 fancy indexing: get a subset of an ndarray by explicitly passing the desired order:
arr[[4, 3, 0, 6]]
arr[[-3, -5, -7]]

with multiple lists of indices, elements corresponding to each tuple of indices are returned
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
will select [1, 0], [5, 3], [7, 1], [2, 2]

arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]] returns a rectangular subset

fancy indexing always returns a copy of the data

142 arr.T shows the transpose, without copying data

143 arr.transpose((1, 0, 2)) permutes multi-dimensional arrays (also a view)

arr.swapaxes(1, 2)

144 ufuncs (universal functions) operate on all elements of ndarrays

np.sqrt(arr)

146 some ufuncs:
unary: abs, fabs, sqrt, square, exp, log, sign, ceil, floor, rint, modf, isnan, isfinite, logical_not, sin, cos, tan, sinh, arcsinh
binary: add, subtract, multiply, divide, floor_divide, power, maximum, minimum, fmax, fmin, mod, copysign, greater, greater_equal, less,
less_equal, equal, not_equal, logical_and, logical_or, logical_xor

147 points_x = np.arange(-5, 5)
points_y = np.arange(-10, 12)
xs, ys = np.meshgrid(points_x, points_y)

149 np.where is "x if condition else y" in vectorized form
result = np.where(cond, xarr, yarr)
np.where(arr > 0, 2, arr)

150 simple statistics: sum, mean, std

arr.mean(axis=1)  # mean by columns

cumsum, cumprod

153 (arr > 0).sum()  # count number of positive values

bools.any()
bools.all()

0 is falsy for numeric arrays

153 arr.sort()

an axis may be passed: arr.sort(1)

154 5% quantile:
large_arr.sort()
large_arr[int(0.05 * len(large_arr))]

154 np.unique(names)

155 np.in1d(values, [2, 3, 6]) tests if elements of values are in [2, 3, 6]

other set methods: intersect1d, union1d, settdiff1d, setxor1d

156 np.save('some_array', arr)
np.load('some_array.npy')
np.savez('array_archive.npz', a=arr, b=arrb)
np.savez_compressed('array_archive.npz', a=arr, b=arrb)

157 np.dot(x, y) is the same as x.dot(y) and x @ y

numpy.linalg contains standard matrix operations

common linalg functions: diag, dot, trace, det, eig, inv, pinv, qr, svd, solve, lstsq

159 random number generators
np.random.randn(2, 3)
np.random.normal(size=(4, 4))

160 np.random.seed(1223)

rng = np.random.RandomState(1234)
rng.randn(10)

functions: seed, permutation, shuffle, rand, randint, randn, binomial, normal, beta, chisquare, gamma, uniform

163 argmax: returns the first index of the array's max value
