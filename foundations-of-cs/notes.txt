Ch. 1: Mechanization of Abstraction

p. 2

Example of exam scheduling without conflicts: a course-conflict graph with edges representing at least one student taking both courses

p. 3

Definitions of data models, data structures, and algorithms.

Data model: abstraction used to describe problems
Data structure: programming language constructs used to represent data models
Algorithm: technique used to obtain solutions by manipulating data

p. 7

The list data model in C

p. 14

The static part of the C data model: the type system

Union types

p. 15

Pointer types

p. 17

typedef

Ch. 2: Iteration, Induction, and Recursion

p. 28

Self-definition, basis-induction, "basis" case, and "inductive" case

p. 29-31

Selection sort

p. 34-35

Inductive Proofs (weak induction)

p. 36

Why proofs by induction work? Technically, induction must be accepted as axiomatic.

First informal proof: Iteration of the inductive step
Second informal proof: Least counterexample (minimal counterexample):
  Suppose S(n) is false for some value a, the least nonnegative integer for which S(a) is false.
  If a = 0, we contradict the basis, S(0), so a must be greater than 0.
  Now, if S(a) is false, S(a-1) is true (because a is the least nonnegative integer where S(a) is false).
  Replacing n with a-1 in the inductive step, S(a-1) implies S(a). Since S(a-1) is true, S(a) must be true: another contradiction.
  Because of these contradictions, S(n) must be true for any n >= 0
  
  (what if a = 1?) We showed how the inductive step holds, so S(a) cannot be false.

p. 38

Error-detecting codes

p. 43

Formulas for sums of arithmetic and geometric series

p. 44

Template for simple (weak) inductions

p. 45

Complete (also called strong or perfect) induction: entitlement to use S(i) for all values of i from the basis value up to n.

1. Prove the basis, S(0)
2. As an inductive hypothesis, assume S(0), S(1), ... , S(n) to be true. With these statements, prove that S(n+1) holds.

p. 46

Justifying complete induction (with a "least counterexample" argument)

p. 47

Associativity and commutativity

p. 51

A template for all inductions

1. Specify the statement S(n) to be proved. Say you are going to prove S(n) by induction on n. Explain what n represents.

2. State the basis case(s). These will be the integers i0 ... j0

3. Prove each of the basis cases S(i0), S(i0 + 1), ..., S(j0).

4. Set up the inductive step by stating that you are assuming S(i0), S(i0 + 1), ..., S(n) and want to prove S(n + 1), with n >= j0. Express S(n + 1) by substituting n + 1 for n in the statement S(n).

5. Prove S(n + 1) under the assumptions mentioned in (4). You are free to use any or all of the statements of the inductive hypothesis.

6. Conclude that S(n) is true for all n >= i0 (but not necessarily for smaller n).

Example; (p. 41, Ex. 2.3.1)

Sigma(from i=1 to n) of i = n(n + 1) / 2
  (Sigma = Oversized sigma, summation)

1. Statement S(n): Sigma(from i=1 to n) of i = n(n + 1) / 2 for any integer n >= 1.

2. Basis case: n = 1.

3. Sigma(from i=1 to n) of i = 1 * (1 + 1) / 2 = 2 / 2 = 1

4. S(n + 1) = (n + 1)((n + 1) + 1) / 2 = (n + 1)(n + 2) / 2
     = (n^2 + 3n + 2) / 2

5. Sigma(from i=1 to n+1) of i = Sigma(from i=1 to n) of i + n + 1.
                               = n(n + 1) / 2 + (n + 1)
							     (we are writing Sigma(i->n) of i as S(n))
							   = (n^2 + n) / 2 + (2 * (n + 1)) / 2
							   = (n^2 + n + 2n + 2) / 2
							   = (n^2 + 3n + 2) / 2 = S(n + 1) as in (4)

6. Therefore, we conclude that S(n) is true for n >= 1.

p. 52

A loop invariant (or inductive assertion) is a statement S that is true each time we enter a particular point in the loop. This statement, S, is then proved by induction on a parameter that measures how many times we have gone around the loop.

p. 57

Loop invariants for while-loops

p. 59

Recursive (or inductive) definitions: one or more classes of closely related objects or facts are defined in terms of the objects themselves. The definition must not be meaningless, nor paradoxical.

A recursive definition involves:

1. One or more basis rules, in which simple objects are defined

2. One or more inductive rules, whereby larger objects are defined in terms of smaller ones in the collection.

p. 60

Example: the factorial function

p. 64

Example: Balanced parentheses

p. 69

Recursive functions may be direct or indirect (only a second, third, or other function calls the original one)

p. 70

Example: factorial function in C

p. 72

Backward induction (selection sort where we swap the smallest element with the first one, and recursively sort the remainder)

p. 74

Divide-and-Conquer (definition)

p. 75

Merge Sort: a recursive, divide-and-conquer algorithm

p. 77

merge(lst1, lst2) function

p. 79

split(lst) function

p. 81

mergeSort(lst) function

p. 83

Recursive makeList() function

p. 85

Proving properties of recursive programs
Factorial and Linked list

p. 91

Benchmarking definition

p. 92

Profiling definition: determining where a program is spending its time

Statement counter: counts the number of times a statement is executed on a given set of inputs

90-10 rule: 90% of the running time is spent in 10% of the code

p. 97

Big-oh notation (definition)

p. 98

Template for big-oh proofs

p. 101

Template for proofs that a big-oh relationship is false

p. 103

Common running times

O(1)        constant
O(log n)    logarithmic
O(n)        linear
O(n log n)  n log n
O(n^2)      quadratic
O(n^3)      cubic
O(2^n)      exponential

p. 106

Logarithms in running times

log_2(n) is the number of times we have to divide by 2 to get down to 1

p. 108

Incommensurate functions are those that are not big-oh of each other.

p. 109

Analyzing the running time of a program

p. 116

Recursive rule for bounding running time

p. 120

Determine running time by climbing the structure tree (recursively)

p. 129

Program analysis in a nutshell

p. 132

Analyzing recursive functions: a recurrence relation relates the running time of a function F, T_F(n), to functions T_G(k) of other functions G in the program with argument sizes k.

p. 142

Inductions that skip some values: showing a T(n) using powers of 2 also shows it is true for all n, because T(n) does not decrease as n increases.

p. 145

Generalized form for simplest type of recurrence:

Basis: T(1) = a
Induction: T(n) = T(n-1) + g(n)

Division into two subproblems:

Basis: T(1) = a
Induction: T(n) = 2T(n/2) + g(n) for n = a power of 2 and greater than 1

p. 151

Summary of Solutions to common recurrence relations: O(n^(k+1)), O(c^n), O(n^log_d(c)), O(n^k), O(n^k log n)

p. 154

A function that takes time O(n^k) and calls itself with input of size n-1 takes time O(n^(k+1))

A function calling itself twice with recursion going on for log_2(n) levels (like merge sort) has running time O(n log n) times the work done at each call, plus O(n) times the work done at the basis.

A function calling itself twice with recursion going on for n levels (like a Fibonacci program) has a running time exponential in n.

