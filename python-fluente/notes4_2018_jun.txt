# Fourth reading, began 11 jun 2018

30 Example: deck of cards

from collections import namedtuple
Card_tuple_subclass = namedtuple('Card_display_name', 'rank suit')

def __getitem__(self, position):
    """allows evaluation of deck[0], deck[-1], etc."""
    return self._cards[position]

31 random.choice picks an element from an array, range, or the deck, which implements __getitem__

33 len in CPython actually reads ob_size of a C struct. It's much faster, so it's the reason len is a function, not a method

35 __abs__, __add__, __mul__, __repr__

36 __repr__ should return the code needed to recreate the represented object, such as Vector(1, 2)

__str__ should produce a suitable string for the end user. If __str__ is undefined, __repr__ is called.

38 https://www.python.org/dev/peps/pep-0357/
__index__ allows any object to be used for slicing (in particular, NumPy uses different sized integers, that should be allowed inside slices)

45 list, tuple, and collections.deque can store items of different types. They store references to the objects they contain.

str, bytes, bytearray, memoryview, and array.array can store items of only one type.

mutable: list, deque, bytearray, array.array, memoryview
immutable: tuple, str, bytes

46 listcomp = list comprehension
genexp = generator expression

47 line breaks are ignored inside (), [], and {}. \ is not needed at the end of lines inside these brackets.

49 Cartesian product

colors = ['red', 'blue']
sizes = ['S', 'M', 'L']
tshirts = [(size, color) for size in sizes for color in colors]
# [('S', 'red'), ('S', 'blue'), ('M', 'red')...]

50 genexps save memory and should be used unless a list is really needed

symbols = '@#$'
t = tuple(ord(symbol) for symbol in symbols)  # (64, 35, 36)

54 unpacking a tuple as arguments of a function

t = (20, 8)
quotient, remainder = divmod(*t)

55 use * to capture excessive arguments. The starred variable may be anywhere. Unpacking structures may also be nested, such as (a, b, (c, d)).

a, b, c* = range(5)  # c is [2, 3, 4]

a, *b, c = range(4)  # b is [1, 2]

57 namedtuples have the _asdict() instance method that returns an OrderedDict

61 slices may be named, such as column ranges in a text spreadsheet
UNIT_PRICE = slice(40, 52)

62 in NumPy, the slice syntax a[m:n, k:l] returns a 2-D slice

62 Slices may be used in assignments to splice and remove elements

64 Use [['_'] * 3 for i in range(3)] instead of [['_'] *  3] * 3 because the latter will repeat the same list reference three times.

69 avoid putting mutable items in tuples

69 sorted() has two optional parameters: reverse=True and key=str.lower, len, etc.

70 key is also used in min(), max(), itertools.groupby(), heapq.nlargest()

72 bisect.bisect(lst, x) is an alias for bisect_right() and returns an index where x should be inserted in lst, such as lst.insert(idx, x). bisect_left() only differs from bisect() when x is already in lst.

73 use bisect to separate values into buckets

import bisect

def grade(score, breakpoints=[60, 70, 80, 90], grades="FDCBA"):
    i = bisect.bisect(breakpoints, score)
    return grades[i]

74 bisect.insort(seq, item) inserts item into seq, maintaining it in ascending order.

75 array.array is optimized for containing only numbers of the same type

array has the methods fromlist(), fromfile(), tolist(), and tofile()

78 memoryview() is a class that allows byte-by-byte manipulation of data structures without making a copy

82 deque

83 deque.rotate(n) : if n > 0, items are shifted to the right, otherwise to the left if n < 0. Items are moved in-place

85 queue.Queue is used for communication between threads. deque is used as a collection.

multiprocessing is used for communication between processes.

heapq provides functions to operate on lists; call heapify(lst)

91 trick to sort a mixed list of strings and ints: sorted(lst, key=int) 

94 use isinstance(3, int) to check the type of an object

95 ways of creating dicts:

a = dict(one=1, two=2)
b = {'one': 1, 'two': 2}
dict comprehensions { key: value for... }

97 d.get(key, [default])
d.setdefault(key, [default])
d.keys()
d.values()
d.update(m)

101 dd = defaultdict(list)  # call with a default factory (without arguments)
But dd.get(k) will not call the factory

105 collections.OrderedDict
collections.ChainMap
collections.Counter
collections.UserDict

106 Subclassing UserDict is preferable to dict because certain overwritten dict methods do not get called. The actual data is stored in self.data

108 from types import MappingProxyType
MappingProxyType(d) creates a mappingproxy object for reading items of a dict

113 Set comprehensions {chr(i).upper() for i in range(48, 128)}

115 for a set s:
s.discard(e)  # does not raise an error if e does not exist
s.remove(e)   # raises KeyError if e does not exist

122 if __eq__ is implemented, __hash__ should be too. If a == b, then hash(a) == hash(b) must also be true. If __eq__ depends on mutable state, __hash__ should raise a TypeError ("unhashable type")

131 bytes is immutable, bytearray is mutable

132 seq[0] == seq[:1] is only true for str. For other sequence types, seq[:1] will return the same sequence type, while seq[0] is of an item type

132 \t, \n, and \r are escape sequences for tab, newline, and carriage return

134 Using struct with memoryview

142 Use the chardet package to detect a text file's encoding

145 always pass encoding="???" when reading and writing text files

151 from unicodedata import normalize
# 'NFC', 'NFD', 'NFKC', 'NFKD' (Normalization Forms)

NFC generates the smallest string possible. It is recommended to use NFC

'K' stands for Compatibility. Information may be lost; for example, 4^2 may be replaced by 42.

154 S.casefold() is used for caseless comparisons

156 the custom function shave_marks() removes diacritics

159 locale-specific sorting with key=locale.strxfrm. However, the locale must be installed in the underlying OS. Most successful in GNU/Linux

161 Alternative for Unicode text sorting: the PyUCA package

175 Functions are first-class objects (for example, round() is of <class 'builtin_function_or_method'>. User functions are <class 'function'>)

177 A higher-order function is one that accepts functions as arguments or returns a function

179 all(iterable) checks whether all values are True (or truthy), any(iterable) checks if at least one is truthy

180 a lambda expression's body is limited to pure expressions (assignments, while, try are not allowed)

181 The 7 callable objects are:
- builtin functions
- builtin methods
- user-defined functions
- user-defined methods
- classes (__new__, then __init__ are called)
- instances (if __call__ is defined)
- generator functions (functions or methods that have the yield keyword)

182 callable() checks if an object is callable

182 When creating an instance that accepts a list, it's a good idea to make a local copy: self._items = list(items)

185 * and ** in function parameters

187 required keyword parameters may be placed after a single * in the parameter list: def f(a, *, b): ...

190 how to use 'signature' in the 'inspect' module

192 function annotations such as def clip(text:ster, maxLen:'int > 0'=80) -> str: serve merely as metadata. There are no checks or guarantees

195 the 'operator' module includes many arithmetic operators that are more readable than an equivalent lambda expression.

from functools import reduce
from operator import mul

def fact(n):
    return reduce(mul, range(1, n+1))

195 operator.itemgetter(i, j, ..., k) work like lst[i], returning the value of the ith item (or a tuple if there are many indices).

It can be used as the key(s) in sorting with respect to one or more columns

a = [0, 10, 20]
ig = itemgetter(0, 2)
ig(a)  # (0, 20)

sorted(b, key=itemgetter(1))

196 attrgetter extract attributes (fields) from objects

197 iadd, iand, etc. are inplace operator like += and &=

197 methodcaller(f, g, ...) calls the methods f, g, etc. on the given ovject argument

198 functools.partial creates a new function with some of the arguments of the original function fixed (frozen in place)

def f(a, b):
    return a + b
    
addTo9 = partial(f, 9)

addTo9(1)  # 10

If a function is called often with the same argument, such as unicode.normalize('NFC', s), it may be worthwhile to use partial.

200 partialmethod works on methods

206 the classic Strategy pattern defines a family of algorithms, encapsulates them and makes them interchangeable. The algorithm can vary independent of the clients who use them.

207 example: different discounts for different clients and orders. A concrete strategy is chosen by the client of the context class.

213 a new promotion object is not needed, because a promotion function may be called directly.

213 Strategy objects are often good Flyweights (a shared object)

214 add available discount functions to a list (takes advantage of functions being first-class citizens) and return max(promo(order) for promo in promos) (use a genexp instead of unnecessarily creating a listcomp)

However, if a promo is added, the promos list needs to be updated.

215 use inspect to find functions named '_promo' to dynamically compute the best promo

216 the Command pattern decouples a Caller object from the Receiver, which implements the operation.

217 a class that implements __call__ can iteratively call other functions stored as an instance variable.

222 nonlocal is often needed for writing custom decorators

223 a decorator is a callable that accepts another function as an argument (the decorated function). It returns a function. Classes may also be decorated.

@decorate
def target():
    print("running target")

is the same as

def target():
    print("running target")
target = decorate(target)

224 decorators are run when a module is loaded (import time), and not at run time

227 using a decorator to add (promo) functions to a registry

229 variables that are assigned in a function are considered local

230 a variable can be declared global in a function

232 a closure is a function with an extended scope, enclosing non-global variables not defined in its body

234 variables not associated in the local scope are "free variables"

234 closures can be inspected with fn.__code__.co_varnames, .co_freevars, and fn.__closure__

235 the only scenario where a function uses external, non-global variables is when it is nested in another function

236 because variable assignments can only be done with local variables, the nonlocal declaration is needed in creating closures

237 'clock' decorator example

239 @functools.wraps copies relevant attributes from the decorated function to the decorator

240 @functools.lru_cache() implements memoization. It stands for Least Recently Used (a limited cache where items not recently used are discarded)

241 @functools.lru_cache() is written with parentheses. It has default arguments maxsize=128 and typed=False. If maxsize=None, the cache is unlimited. The cache size should be a power of 2. Parameters of the decorated function must be hashable

244 there is no function or method overloading in Python

244 @singledispatch is used to define a generic function. A different implementation is picked based on the type of the first argument. Each implementation should look like:

@singledispatch
def htmlize(obj):
    ...

@htmlize.register(numbers.Integral)
def _(n):
    ...    

245 if possible, register functions with ABCs instead of concrete types like int or list

246 @singledispatch offers modular extension: code is not limited to a single class (like Java) or a single function (with if/elif/else blocks)

246 stacking decorators like this:

@d1
@d2
def f():
    ...

is the same as d1(d2(f))

247 to create parametrized decorators, a decorator factory must be created. This decorator factory should accept the desired parameters, create a decorator that decorates the target function, and finally return it.

258 variables are labels, not boxes (if you put the same list in two boxes, changing one will in fact affect both)

258 a variable is assigned to an object, and not the other way around

260 several variables assigned to the same object are aliases

262 'is' and 'is not' check identity, while == checks the values

262 to check for None, use 'x is None' or 'x is not None'

264 lst2 = list(lst1) and lst1[:] creates shallow copies (only references are copied)

267 copy.deepcopy() creates deep copies. copy.copy creates shallow copies.

269 in Python function calls, the parameters turn into aliases of the arguments (call by sharing). Arguments are passed using "call by object reference" (technically call by value, where the value is always an object reference)

immutable arguments are not changed, while mutable ones can be altered in place. However, they cannot be reassigned.

270 don't use mutable values as function keyword defaults

273 usually, if a function or class alters mutable parameters, a copy should be created, such as list(items), so that the client's original data remains unchanged

274 del only removes names, not objects

274 implementing __del__ is rarely needed

275 weakref.finalize registers a callback that is called when an object is destroyed

276 weak references (weakref.ref) do not prevent the garbage collector from destroying an object

277 it is better to use weakref collections, such as WeakKeyDictionary, WeakValueDictionary, WeakSet, and finalize

279 lists and dicts cannot be targets of weakrefs, but user-defined subclasses such as class MyList(list) can be targets.

280 calling copy() or constructors of immutable types return the same object

282 Assigning a new value to an existing variable does not change the previously associated object. It is merely "rebinding"

291 call a type constructor in a class' __init__ to capture errors when instantiating it.

293 for a @classmethod, cls is used as the first parameter (instead of self for regular methods)

293 classmethods are typically used as alternative constructors

293 a @staticmethod does not accept a special first parameter. It is like a regular function that happens to be inside a class definition

296 str.format() can be used with datetime objects

from datetime import datetime
"It is now {:%I:%M %p}".format(datetime.now())

296 custom __format__(self, fmt_spec='')

299 using two underscores at the beginning of a attribute name makes it private. @property marks a getter method of a property. The method name should be named after the private attribute.

def __init__(self, x):
    self.__x = float(x)

@property
def x(self):
    return self.__x

299, 301 a hashable instance should be immutable because the hash value of any instance should not change

300 a custom __hash__ function can be the XOR (^) of the hashes of its components

305 adding two underscores (__myAttr) to a name "mangles" the name. It will become _MyClass__myAttr and prevents accidental access, but does not forbid access (like 'private' in Java).

306 by convention, a single leading underscore has the same "protective" effect without mangling the name

307 __slots__ saves memory, but are not inherited. __slots__ attributes must be defined in each class individually

307 a tuple can be used in defining __slots__

class Vector2d:
    __slots__ = ('__x', '__y')

309 if weak references are needed with custom classes that use __slots__, __weakref__ must be included in __slots__

309, 332 in general, __slots__ is only worthwhile if you have millions of instances. it should not be used merely to prevent instance attribute creation

310 class attributes can be used as default values for instance attributes.

311 subclassing to override a class attribute is more commonplace than altering the target class' class attribute directly

class ShortVector2d(Vector2d):
    typecode = 'f'  # 'd' in original Vector2d

312 in __repr__, use class_name = type(self).__name__ so it gives the proper result in subclasses

315 Python's approach to attributes is the opposite of Java's: in Java, a public attribute cannot later be implemented as getters and setters without breaking existing code.

In Python, public attributes can later be further controlled with properties (which work as getters and setters)

319 in implementing Vector, composition is used, not inheritance

320 reprlib can generate __repr__ outputs of limited length

322 calling __repr__ should never raise an Exception or Error because it is used in debugging

322 a protocol is an informal interface, defined in documentation but not enforced in code

322 the Python sequence protocol implies only __len__ and __getitem__

323 to support iteration, only __getitem__ is required.

327 to make a custom object sliceable, check for the type of index in

def __getitem__(self, index):
    if isinstance(index, slice):
        ...

329 __getattr__ is called if an attribute is not found via dot notation (myobj.x)

330 implementing __setattr__ can prevent unwanted attribute assignments. usually, if __getattr__ is implemented, __setattr__ should be too

334 when using functools.reduce() for calculating hashes, the optional third parameter (initializer) should be 0, to avoid a TypeError with empty sequences (use 0 for +, |, and ^, and 1 for * and &)

336 zip is lazy so it is perfect for checking pairs (or larger tuples) of iterables.

if we assign z = zip(a, b, c), zip(*z) will reverse the operation

337 use itertools.zip_longest(iter1, ..., fillvalue="_") if iterables are of different lengths

344 itertools.chain(*iterables) concatenates its arguments

352 An abstract class represents an interface (C++, Stroustrup)

353 Generally speaking, creating custom ABCs (Abstract Base Classes) is only done by framework creators

353 a class' interface is its public and inherited attributes (data and methods), including dunder methods such as __getitem__

354 protocols are independent of inheritance; a class can implement many protocols

355 the ABC Sequence contains __getitem__, __contains__, __iter__, __reversed__, index, and count. It inherits methods from the superclasses Container (__contains__), Iterable (__iter__), and Sized (__len__)

356 the sequence protocol has two methods: __getitem__ and __len__

359 monkey-patching is altering a module or class at run time

361 "goose typing" (a term invented by Alex Martelli) is that isinstance(obj, abc_cls) is now OK (the metaclass of abc_cls is abc.ABCMeta)

362 isinstance(x, numbers.Number) checks whether x is a number

362 the class method register() allows an end-user to declare that a certain class should be a virtual subclass of an ABC

363 check for a sequence with isinstance(a, collections.abc.Sequence)

363 issubclass() is more acceptable when checking if a class subclasses ABCs

365 by subclassing collections.MutableSequence we must implement __setitem__, __delitem__, and insert

367, 371 most ABCs are in collections.abc. The abc module has abc.ABC, which is needed to create new ABCs.

367 a mixin method is a concrete implementation of an ABC method or of a mixin class

369 callable() checks if an object can be invoked, but there is no hashable(). Use isinstance(obj, collections.Hashable) instead

369 numbers.Number is the highest type of the numerical tower, then Complex, Real, Rational, and Integral

369 Decimal does not belong to any of numbers' classes

370 implementation of a Tombola ABC to represent picking and removing numbers randomly

371 @abc.abstractmethod marks an abstract method. Its body is empty except for a docstring (don't write anything, not even a pass or ...)

372 an ABC may have concrete methods. They should only count on the interface defined by the ABC

372 an abstract method may have an implementation, even if subclasses override them. To use them, use super()

373 LookupError is a superclass of IndexError and KeyError

375 @abstractmethod should be the innermost decorator (closest to def)

376 randomizer = random.SystemRandom() offers "random bytes suitable for cryptographic applications"

378, 384 @MyABC.register or MyABC.register(MySubclass) makes a virtual subclass of MyABC. The virtual subclass will return True for issubclass and isinstance, but will not inherit anything from MyABC. No checks are made, and unimplemented methods will raise Exceptions at run time

381 __subclasses__() returns a list of direct subclasses and _abc_registry is a data attribute associated with a WeakSet with weakrefs to virtual subclasses registered with the ABC

385 __subclasshook__() may cause a custom class to be recognized as a subclass of an ABC. For example, a class defining __len__ will be a subclass of abc.Sized

391 Strong vs. Weak typing: strong typing does not implicitly convert between types.

Static vs. Dynamic typing: static typing checks types during compile time. Dynamic typing does so at run time
